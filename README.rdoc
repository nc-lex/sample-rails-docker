= Sample Rails app on Docker

== Configuration

=== Docker Engine

<code>Dockerfile</code> defines how a single Docker image is built.

Docker caches for each line in <code>Dockerfile</code>, and will check modifications of files and use the corresponding cache to skip steps and speed up rebuilding. Therefore, lines that changes more often (such as <code>Gemfile</code>) should be put after lines that changes less often (such as <code>apt-get install build-essential</code>)

In order to prevent the entire <code>Gemfile</code> to be <code>bundle install</code>ed when the Docker image is rebuilt, a seperate <code>Gemfile</code> is placed under <code>.docker</code> folder. This <code>Gemfile</code> should include essential gems and be relatively stable. In <code>Dockerfile</code>, it will be <code>bundle install</code>ed before the actual <code>Gemfile</code> and cached by Docker so that installing the actual <code>Gemfile</code> will be faster. The  contents and versions in this minimal <code>Gemfile</code> won't affect the app, since the app still relies on the actual one.

The following are parts of <code>Dockerfile</code> that should be configured, marked as <code>TODO</code>.

1. <code>FROM ruby:2.2-slim</code> defines the base Docker image to be used. Ruby images can be found at https://hub.docker.com/_/ruby

1. <code>ENV RAILS_ROOT /var/www/sample_app</code> defines where the app will run in the Docker container.

1. <code>RUN apt-get install -y mysql-client libmysqlclient-dev</code> installs non-RubyGems dependencies for <code>mysql2</code> gem. <code>pg</code> and older version of <code>nokogiri</code> required by rails also depend on non-RubyGems libraries.

1. Sometimes <code>bundle install</code> may fail before some particular tweaks are made. These tweaks can be placed here.

=== Docker Compose

<code>docker-compose.yml</code> defines how to organize multiple Docker containers as services into a single application, and allows for additional configurations for each container.

The following are the important labels in the file.

build::
  Call <code>docker build</code> with the <code>Dockerfile</code> specified to build the image for the service container.
  
links::
  Allows connecting to another service by its service name, or an alias if specified.

command::
  The command that will be run when the container starts. Overrides <code>COMMAND</code> in <code>Dockerfile</code>.
  Should be placed in brackets to be <code>exec</code>ed and keeps PID = 1.
  
env_file::
  The list of environment variables to be set. Sensitive strings such as database password can be place here.
  
ports::
  Expose ports of the container and provide mapping between ports of the Docker Engine (as in <code>dockerhost:*3000*</code>) and ports of the container (as in <code>rails s -p *3000*</code>).
  
  See "Usage" section for more about <code>dockerhost</code>.
  
volumes::
  * If a host path is specified before <code>:</code>, mounts directories of the host system to the container.
  
    See "Volume Mounting" section for issues caused by this feature.
    
  * If a name is specified before <code>:</code>, declares the container folder as a named volume which preserves data even if the container is deleted.

image::
  Directly use a Docker base image without a <code>Dockerfile</code> build.
  
=== Database

In <code>config/database.yml</code>, <code>host</code> should be set to <code>db</code> to connect to the database service defined in <code>docker-compose.yml</code>

Alternatively, set <code>DATABASE_URL</code> in <code>.docker/.env</code> according to the following format.

  DATABASE_URL=<adapter>://<username>:<password>@db/<database>?encoding=<encoding>&pool=<pool>
  
=== Ignore

<code>.dockerignore</code> defines files to be excluded when copied, etc in <code>Dockerfile</code>. Files won't be excluded when mounted.

<code>.gitignore</code> should include <code>.docker/.env</code>.

== Usage

* Starts "Docker Quickstart Terminal" from Launchpad. After it completes startup it will display the current Docker IP address. It will be referred to as <code><DockerHost></code> later.

  Run <code>docker-machine ip</code> in Terminal returns <code><DockerHost></code>.

  Alternatively, after the "Docker Quickstart Terminal" completes startup, an independent terminal with the following environment variables set (in <code>~/.bash_profile</code>, etc) will also work.

    export DOCKER_HOST=tcp://$(docker-machine ip):2376
    export DOCKER_CERT_PATH=~/.docker/machine/machines/default
    export DOCKER_TLS_VERIFY=1
    export DOCKER_MACHINE_NAME=default

* Go to the app root directory, and run 

    docker-compose build
    docker-compose up

* Run <code>.docker/bash</code> to start a console in the app container for debugging, etc.

  Note that <code>.docker/bash -s db</code> connects to the database container.

* It might help to put <code><DockerHost> dockerhost</code> in the <code>hosts</code> file.

  Open <code>dockerhost:3000</code> in browser to see the running app.
  
* Press <code>Ctrl + C</code> to stop the containers.
  
* Alternatively, run <code>docker-compose start</code> to run the containers in background, <code>docker-compose stop</code> to stop them, and <code>docker-compose logs</code> to check the outputs of the containers.

== Issues

=== Volume Mounting

http://i.imgur.com/oUTQQh7.png

As shown in the graph above, Docker can mount host directories directly as container volumes. Normally it's used to mount the source folder to avoid <code>docker-compose build</code> after every code update. However, this creates some issues.

* In the <code>development</code> environment, Rails monitors on the file system to reload any changes in the Ruby source files. The monitoring may not work very well in the mounted directory, leading to a delay between file updates and changes in the browser.

* Permissions on the mounted file system originates from the host file system, and cannot be altered by the container.

  MySQL and PostgreSQL will attempt to take ownership of its data directory. Mounting the data directory to the host (for backing up, etc) will prevent them from doing so and successfully starting up.
  
  However, their corresponding Docker images define their data directories as volumes, so it's easy to access it from another container.
  
    app:
      volumes_from:
        - db
      
  For example, declaring the above in <code>docker-compose.yml</code> allows the app container to access the data directory of the database container by the same path (e.g. <code>/var/lib/mysql</code>).

== Troubleshooting

* Run <code>.docker/scripts/cleanup.sh</code> will delete any non-running containers, dangling images, and dangling volumes.

  Run <code>docker-compose rm</code> to remove containers in current Docker Compose context (so that they will be recreated from images when started).

* The entrypoint script will automatically initialize the Rails database. Deleting <code>tmp/init</code> forces it to initialize again.

* Do not set RAILS_ENV or MYSQL_HOST in <code>.docker/.env</code>
