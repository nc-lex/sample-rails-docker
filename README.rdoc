= Sample Rails app on Docker

== Introduction to Docker

http://i.imgur.com/2c5iYX4.png

Docker is a Linux container and virtualization tool. It's more lightweight than virtual machines, that the host Linux kernel is shared by all Docker instances. Similar to virtual machines, each instance runs on an independent file system. The file system of Docker is layered, allows easy management of incremental changes and version control.

http://i.imgur.com/6xHD7Kl.png

OS X doesn't have the required Linux kernel. Therefore, when running on OS X, Docker runs on a Linux virtual machine (created by Docker Machine).

=== Vocabulary

container::
  A Docker instance that emulates a computer.
  
image::
  The "base class" of containers. Defines how a container is created. <code>debian</code>, <code>ubuntu</code>, <code>ruby</code>, and <code>mysql</code> are among the popular images. They are built from steps defined in a <code>Dockerfile</code>.
  
Docker Engine::
  Builds and manages Docker images. Runs and manages Docker containers.
  
Docker Compose::
  Organize multiple Docker containers. Many of its commands resemble the ones of Docker Engine.
  
Docker Machine::
  A virtual machine tool to create a Linux environment for Docker to run on Windows and OS X.

== Configuration

=== Installation

See https://docs.docker.com/engine/installation/mac/

=== Docker Engine

<code>Dockerfile</code> defines how a single Docker image is built.

Docker caches for each line in <code>Dockerfile</code>, and will check modifications of files and use the corresponding cache to skip steps and speed up rebuilding. Therefore, lines that changes more often (such as <code>Gemfile</code>) should be put after lines that changes less often (such as <code>apt-get install build-essential</code>)

In order to prevent the entire <code>Gemfile</code> to be <code>bundle install</code>ed when the Docker image is rebuilt, a seperate <code>Gemfile</code> is placed under <code>.docker</code> folder. This <code>Gemfile</code> should include essential gems and be relatively stable. In <code>Dockerfile</code>, it will be <code>bundle install</code>ed before the actual <code>Gemfile</code> and cached by Docker so that installing the actual <code>Gemfile</code> will be faster. The  contents and versions in this minimal <code>Gemfile</code> won't affect the app, since the app still relies on the actual one.

The following are parts of <code>Dockerfile</code> that should be configured, marked as <code>TODO</code>.

1. <code>FROM ruby:2.2-slim</code> defines the base Docker image to be used. Ruby images can be found at https://hub.docker.com/_/ruby

1. <code>ENV RAILS_ROOT /var/www/sample_app</code> defines where the app will run in the Docker container.

1. <code>RUN apt-get install -y mysql-client libmysqlclient-dev</code> installs non-RubyGems dependencies for <code>mysql2</code> gem. <code>pg</code> and older version of <code>nokogiri</code> required by rails also depend on non-RubyGems libraries.

1. Sometimes <code>bundle install</code> may fail before some particular tweaks are made. These tweaks can be placed here.

=== Docker Compose

<code>docker-compose.yml</code> defines how to organize multiple Docker containers as services into a single application, and allows for additional configurations for each container.

The following are the important labels in the file.

build::
  Call <code>docker build</code> with the <code>Dockerfile</code> specified to build the image for the service container.
  
links::
  Allows connecting to another service by its service name, or an alias if specified.

command::
  The command that will be run when the container starts. Overrides <code>COMMAND</code> in <code>Dockerfile</code>.
  Should be placed in brackets to be <code>exec</code>ed and keeps PID = 1.
  
env_file::
  The list of environment variables to be set. Sensitive strings such as database password can be place here.
  
ports::
  Expose ports of the container and provide mapping between ports of the Docker Engine (as in <code>dockerhost:*3000*</code>) and ports of the container (as in <code>rails s -p *3000*</code>).
  
  See "Usage" section for more about <code>dockerhost</code>.
  
volumes::
  * If a host path is specified before <code>:</code>, mounts directories of the host system to the container.
  
    See "Volume Mounting" section for issues caused by this feature.
    
  * If a name is specified before <code>:</code>, declares the container folder as a named volume which preserves data even if the container is deleted.

image::
  Directly use a Docker base image without a <code>Dockerfile</code> build.
  
=== Database

In <code>config/database.yml</code>, <code>host</code> should be set to <code>db</code> to connect to the database service defined in <code>docker-compose.yml</code>

Alternatively, set <code>DATABASE_URL</code> in <code>.docker/.env</code> according to the following format.

  DATABASE_URL=<adapter>://<username>:<password>@db/<database>?encoding=<encoding>&pool=<pool>
  
=== Ignore

<code>.dockerignore</code> defines files to be excluded when copied, etc in <code>Dockerfile</code>. Files won't be excluded when mounted.

<code>.gitignore</code> should include <code>.docker/.env</code>.

== Usage

* Starts "Docker Quickstart Terminal" from Launchpad. After it completes startup it will display the current Docker IP address. It will be referred to as <code><DockerHost></code> later.

  Run <code>docker-machine ip</code> in Terminal returns <code><DockerHost></code>.

  Alternatively, after running <code>docker-machine start</code>, an independent terminal with the following environment variables set (in <code>~/.bash_profile</code>, etc) will also work.

    export DOCKER_HOST=tcp://$(docker-machine ip):2376
    export DOCKER_CERT_PATH=~/.docker/machine/machines/default
    export DOCKER_TLS_VERIFY=1
    export DOCKER_MACHINE_NAME=default
    
  (See <code>.docker/scripts/start-default.sh</code>)

* Go to the app root directory, and run 

    docker-compose build
    docker-compose up

* Run <code>.docker/bash</code> to start a console in the app container for debugging, etc.

  Note that <code>.docker/bash -s db</code> connects to the database container.

* It might help to put <code><DockerHost> dockerhost</code> in the <code>hosts</code> file.

  Open <code>dockerhost:3000</code> in browser to see the running app.
  
* Alternatively, run <code>docker-compose start</code> to run the containers in background, <code>docker-compose stop</code> to stop them, and <code>docker-compose logs</code> to check the outputs of the containers.

== Issues

=== Volume Mounting

http://i.imgur.com/oUTQQh7.png

As shown in the graph above, Docker can mount host directories directly as container volumes. Normally it's used to mount the source folder to avoid <code>docker-compose build</code> after every code update on the host. Changes made by the container (such as an update to <code>vendor/cache</code> by <code>bundle package</code>) will also be stored by the host.

However, this creates some issues.

1. The extra layer of Docker Machine on OS X slows the mount down. From the container perspective, the host directories referred here are actually Docker Machine folders, which are the host directories shared by Docker Machine through VirtualBox file sharing.

1. In the <code>development</code> environment, Rails monitors on the file system to reload any changes in the Ruby source files. The monitoring may not work very well in the mounted directory, leading to a delay between file updates and changes in the browser.

1. Permissions on the mounted file system originates from the host file system, and cannot be altered by the container.

* MySQL and PostgreSQL will attempt to take ownership of its data directory. Mounting the data directory to the host (for backing up, etc) will prevent them from doing so and successfully starting up.
  
  However, their corresponding Docker images define their data directories as volumes, so it's easy to access it from another container.
  
    app:
      volumes_from:
        - db
      
  For example, declaring the above in <code>docker-compose.yml</code> allows the app container to access the data directory of the database container by the same path (e.g. <code>/var/lib/mysql</code>).
  
=== Possible Solutions

==== Dinghy

Dinghy is a third-party tool to improve Docker on OS X. It creates its own Docker Machine using NFS, a faster file sharing system than the default VirtualBox file sharing.

Dinghy addresses the #1 issue. For example, through NFS file sharing <code>rake test</code> for this sample app takes around 1.4x time it takes on the host. (In comparison, through VirtualBox file shares it takes around 2.4x time)

Run <code>.docker/scripts/install-dinghy.sh</code> to install Dinghy, then run <code>dinghy up</code> to start Dinghy daemon if it's not running. Run <code>. .docker/scripts/start-dinghy.sh</code> (or use <code>~/.bash_profile</code>, etc) to set environment variables for Dinghy.

== Tips

* Run <code>.docker/scripts/cleanup.sh</code> will delete any non-running containers, dangling images, and dangling volumes.

  Run <code>docker-compose rm</code> to remove containers in current Docker Compose context (so that they will be recreated from images when started).

* The entrypoint script will automatically initialize the Rails database. Deleting <code>tmp/init</code> forces it to initialize again.

* Do not set RAILS_ENV or MYSQL_HOST in <code>.docker/.env</code>.

* <code>docker-compose build</code> can be run routinely to update the Docker images.

  Note that during <code>docker-compose build</code> stage, changes to the context folder (such as updating <code>Gemfile.lock</code> and <code>vendor/cache</code>) will be made on the container file system, and thus will be hidden when the context folder from the host is mounted by Docker Compose. Therefore, run <code>bundle</code> directly in the container console first.
