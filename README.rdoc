= Sample Rails app on Docker

== Configuration

=== Docker Engine

<code>Dockerfile</code> defines how a single Docker image is built.

Docker caches for each line in <code>Dockerfile</code>, and will check modifications of files and use the corresponding cache to skip steps and speed up rebuilding. Therefore, lines that changes more often (such as <code>Gemfile</code>) should be put after lines that changes less often (such as <code>apt-get install build-essential</code>)

In order to prevent the entire <code>Gemfile</code> to be <code>bundle install</code>ed when the Docker image is rebuilt, a seperate <code>Gemfile</code> is placed under <code>.docker</code> folder. This <code>Gemfile</code> should include essential gems and be relatively stable. In <code>Dockerfile</code>, it will be <code>bundle install</code>ed before the actual <code>Gemfile</code> and cached by Docker so that installing the actual <code>Gemfile</code> will be faster. The  contents and versions in this minimal <code>Gemfile</code> won't affect the app, since the app still relies on the actual one.

The following are parts of <code>Dockerfile</code> that should be configured, marked as <code>TODO</code>.

1. <code>FROM ruby:2.2-slim</code> defines the base Docker image to be used. Ruby images can be found at https://hub.docker.com/_/ruby

1. <code>ENV RAILS_ROOT /var/www/sample_app</code> defines where the app will run in the Docker container.

1. <code>RUN apt-get install -y mysql-client libmysqlclient-dev</code> installs non-RubyGems dependencies for <code>mysql2</code> gem. <code>pg</code> and older version of <code>nokogiri</code> required by rails also depend on non-RubyGems libraries.

1. Sometimes <code>bundle install</code> may fail before some particular tweaks are made. These tweaks can be placed here.

=== Docker Compose

<code>docker-compose.yml</code> defines how to organize multiple Docker containers as services into a single application, and allows for additional configurations for each container.

The following are the important labels in the file.

build::
  Call <code>docker build</code> with the <code>Dockerfile</code> specified to build the image for the service container.
  
links::
  Allows connecting to another service by its service name, or an alias specified.

command::
  The command that will be run when the container starts. Overrides <code>COMMAND</code> in <code>Dockerfile</code>.
  Should be placed in brackets to be <code>exec</code>ed and keeps PID = 1.
  
env_file::
  The list of environment variables to be set. Sensitive strings such as database password can be place here.
  
ports::
  Expose ports of the container and provide mapping between ports of the Docker Engine (as in <code>dockerhost:*3000*</code>) and ports of the container (as in <code>rails s -p *3000*</code>).
  
  See "Usage" section for more about <code>dockerhost</code>.
  
volumes::
  Mounts directories of the host system to the container.
  See "Volume Mounting" section for issues caused by this feature.

image::
  Directly use a Docker base image without a <code>Dockerfile</code> build.
  
=== Database

In <code>config/database.yml</code>, <code>host</code> should be set to <code>db</code> to connect to the database service defined in <code>docker-compose.yml</code>

Alternatively, set <code>DATABASE_URL</code> in <code>.docker/.env</code> according to the following format.

  DATABASE_URL=<adapter>://<username>:<password>@db/<database>?encoding=<encoding>&pool=<pool>
  
=== Ignore

<code>.dockerignore</code> defines files to be excluded when copied, etc in <code>Dockerfile</code>.

<code>.gitignore</code> should include <code>.docker/.env</code>.

== Usage

* Starts "Docker Quickstart Terminal" from Launchpad. After it completes startup it will display the current Docker IP address. It will be referred to as <code><DockerHost></code> later.

  Alternatively, after the "Docker Quickstart Terminal" completes startup, an independent terminal with the following environment variables set (in <code>~/.bash_profile</code>, etc) will also work.

    export DOCKER_HOST=tcp://<DockerHost>:2376
    export DOCKER_CERT_PATH=/Users/<Username>/.docker/machine/machines/default
    export DOCKER_TLS_VERIFY=1
    export DOCKER_MACHINE_NAME=default

* Go to the app root directory, and run <code>docker-compose up</code>.

* Run <code>.docker/bash</code> to start a console in the app container for debugging, etc.

  Note that <code>.docker/bash -s db</code> connects to the database container.
  
* Initialize the database, by issuing the following command in the app container console.

    rake db:create
    rake db:schema:load

* It might help to put <code><DockerHost> dockerhost</code> in the <code>hosts</code> file.

== Issues

=== Volume Mounting

http://i.imgur.com/oUTQQh7.png

As shown in the graph above, Docker can mount host directories directly as container volumes. Normally it's used to mount the source folder to avoid <code>docker-compose build</code> after every code update. However, this creates some issues.

* Permissions on the mounted file system originates from the host file system, and cannot be altered by the container.

  MySQL and PostgreSQL will attempt to take ownership of its data directory. Mounting the data directory to the host (for backing up, etc) will prevent them from doing so and successfully starting up.
  
  However, their corresponding Docker images define their data directories as volumes, so it's easy to access it from another container.
  
    app:
      volumes_from:
        - db
      
  For example, declaring the above in <code>docker-compose.yml</code> allows the app container to access the data directory of the database container by the same path (e.g. <code>/var/lib/mysql</code>).
